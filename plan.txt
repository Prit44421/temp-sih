Prompt for AI: Build Kavach — Multi-Platform System Hardening Tool

You are an expert full-stack engineer and security automation developer. Your job: design, implement, test, document, and deliver a production-ready cross-platform system hardening tool named Kavach that meets the specification below. Produce a Git repository with code, tests, Dockerfiles, CI workflow, and a README with usage examples.

High-level goals

A single tool that supports Windows (10/11), Ubuntu (20.04+), CentOS 7+.

Accepts Annexure rules in JSON (user will provide). JSON format described below.

Implements modular OS detection, modular rule modules, remediation, verification, logging, PDF reports, checkpoint/rollback, TUI (interactive terminal UI) and Web UI (browser).

When user runs the main entry point, both TUI and Web UI launch. TUI outputs an access token (one-time token) which is required to access the web UI.

Full audit logs, detailed compliance reports (previous value/state, current value/state, status), rule editor (add/edit/delete), selective rule toggles (hidden UI element; default: selected), and save/restore checkpoints.

Everything must be modular, testable, documented and production-ready.

Required deliverables

Git repo containing:

backend (API + enforcement engine)

frontend (flask)

TUI (terminal interactive UI)

CLI entrypoint kavach (or python -m kavach)

Example Annexure JSON file


README with install/run/test instructions



The tool must run on Linux and Windows (where possible). Use platform checks and gracefully exit/notify if a rule cannot be applied on the current OS.

Suggested tech stack (you may suggest alternatives, but justify)

Backend: Python 3.11+

TUI: Textual (or urwid/prompt_toolkit) for cross-platform TUI.

Web UI: html js css

Database: json

Checkpoint storage of system state: JSON snapshots stored encrypted on disk. Logs to file + rotating handler.

Windows: use PowerShell commands via subprocess or pywin32 where available; support running a PowerShell helper script with admin privileges.

Linux: run sudo commands; prefer Python's subprocess to query/modify sysctl, systemd, files, packages.

Report generation: ReportLab or WeasyPrint (HTML->PDF) for styled PDF output.

Packaging: containerize backend/frontend; provide Windows instructions for running natively.

Authentication: simple token-based access for Web UI generated by TUI at startup (JWT or random HMAC token, short-lived).

Logging: structured JSON logs (timestamp, rule_id, prev_value, new_value, status, user, session_id).

Architecture / components

OS Detection Module: returns OS type/version. Uses platform lib for Python plus distro detection.

Rule Engine:

Loads rules JSON (structure below).

Each rule has id, description, platforms, check_cmd (or function), remediate_cmd, validate_cmd, level (basic/moderate/strict), rollback_action.

Engine supports apply, validate, rollback.

All enforcement is transactional per-rule: create checkpoint → apply → validate → log result.

Checkpoint Manager:

Creates snapshot of prior state for each rule (single-file ).

Snapshots stored with metadata: timestamp, session id, rules changed.

Provide list, restore(checkpoint_id), delete.

Snapshots must be reversible; if a rule changed a file, save the previous file content; if changed registry (Windows), export previous registry value via reg.exe or PowerShell.

CLI & TUI:

CLI to run single commands: kavach scan, kavach apply --level strict, kavach rollback --checkpoint <id>, kavach generate-report --output r.pdf.

TUI launches interactive selection wizard: choose target OS (default=local), choose level, deselect rules (hidden toggle show/hide), preview changes, start hardening, view progress with per-rule status, show access token for Web UI, and allow rollback from TUI.

Web UI:

Dashboard: system info, current compliance status, action center (Start Hardening / Rollback / View Reports / Edit Rules).

Rule editor (add/edit/delete) with JSON import/export.

Reports viewer and PDF export.

Access controlled by the token produced in TUI.

API:

Endpoints for: GET /status, POST /apply, POST /rollback, GET /checkpoints, POST /rules, PUT /rules/:id, DELETE /rules/:id, GET /report/:id.

WebSocket for live enforcement logs.

Security & Privilege model:

The enforcement operations require elevated privileges; code should detect privilege level and warn user.

The web UI token should be short-lived and printed only in TUI (not stored in plain text).



JSON rule format (example)

Provide one canonical example that the agent will implement:

{
  "os": "ubuntu",
  "module": "network",
  "rules": [
    {
      "id": "ubuntu.network.disable-ipv6",
      "title": "Disable IPv6",
      "description": "Ensure IPv6 is disabled if not in use",
      "level": "basic",
      "platforms": ["ubuntu", "centos"],
      "check": {
        "type": "shell",
        "cmd": "sysctl net.ipv6.conf.all.disable_ipv6 | awk '{print $3}'",
        "expect": "1"
      },
      "remediate": {
        "type": "shell",
        "cmd": "sysctl -w net.ipv6.conf.all.disable_ipv6=1 && echo 'net.ipv6.conf.all.disable_ipv6=1' >> /etc/sysctl.conf"
      },
      "validate": {
        "type": "shell",
        "cmd": "sysctl net.ipv6.conf.all.disable_ipv6 | awk '{print $3}'",
        "expect": "1"
      },
      "rollback": {
        "type": "restore_checkpoint"
      }
    }
  ]
}


Rules may use "type": "powershell" on Windows; allow "type": "python" to call a Python function in a rule module for complex checks.

Checkpoint & rollback design (technical)

For each rule execution:

Compute what will change (files, registry keys, sysctl keys, service states).

Create a checkpoint containing: list of changed artifacts, their old values (file contents, registry values, service enablement state), timestamp, rule_id, session_id. Store as encrypted JSON (AES) in ~/.kavach/checkpoints/.

Apply remediation.

Validate. If validation fails, auto-rollback to checkpoint and mark rule as failed.

Provide kavach rollback --checkpoint <id> and TUI option to rollback full checkpoint or selected rules.

Keep an index of checkpoints in DB for fast listing and search.

Example CLI usage
# Start both TUI and web UI (default)
kavach start

# Run headless apply
kavach apply --level moderate --rules-file annexure.json --dry-run

# Rollback
kavach rollback --checkpoint 2025-10-07-12345

# Export report
kavach report --output kavach-report.pdf

UI behavior & UX details

TUI: Wizard-style, progress bar and per-rule log, displays web UI access token (copyable), and QR code (optionally) to open web UI on same network.

Web UI: Dashboard, rules table with filters (level, module, status), ability to hide advanced rules (hidden toggle), rule editor with JSON import/export, start/stop enforcement, live logs via WS.

Default: All rules selected by default; advanced/hidden rules not shown unless "Show advanced" enabled.

Reports: Include severity rating per rule, previous vs current state, pass/fail, timestamp, system metadata (OS, kernel, hostname), and checksum of annexure file used.

Logging & report format

Logs: structured JSON lines stored in ~/.kavach/logs/ with rotating files. Each entry: ts, level, rule_id, action (check|remediate|validate|rollback), prev_state, new_state, status, cmd, stdout, stderr.

Reports: both JSON and PDF. PDF is formatted with a header, summary, and per-rule sections.

Edge cases & safety

If tool cannot gain required privileges, provide a clear user-friendly error and suggestions to run as admin/sudo.

For destructive rules, confirm (in TUI) before applying; provide --force for automation.




Non-functional requirements

Code style: follow PEP8 and use type hints. Format with black.

Security: minimal attack surface — web UI token limited to local network by default; option to bind only to localhost.

Performance: rule execution parallelism configurable; default sequential to simplify checkpoints.

Documentation: README with architecture diagram, admin guide, and rule creation guide.

Files & repo structure (suggested)
kavach/
├─ backend/
│  ├─ app/
│  │  ├─ main.py
│  │  ├─ api/
│  │  ├─ core/
│  │  ├─ rules/
│  │  └─ checkpoints/
│  ├─ Dockerfile
│  └─ tests/
├─ cli/
│  └─ kavach_cli.py
├─ tui/
│  └─ app.py
├─ frontend/
│  ├─ vite/React app
│  └─ Dockerfile
├─ docs/
├─ examples/
│  └─ annexure_example.json
├─ scripts/
│  └─ demo.sh
├─ .github/workflows/ci.yml
└─ README.md

Implementation priorities (minimum viable)

Backend rule engine, JSON rule loader, checkpoint manager (json), CLI commands start, apply, rollback, report.

TUI that launches and prints token.

Web API endpoints + simple UI that authenticates via token and shows rule list + start apply and get report.

PDF report generation & logs.


Extra instructions for the code-writing AI

Produce code incrementally . For each PR-style chunk output: files changed, short test plan, and how to run locally.

When writing OS-altering commands, implement a safe-mock mode used by tests that simulates changes.

Put clearly marked TODOs where platform specific privileged logic must be reviewed for security (e.g., editing /etc/ files, registry writes).

Use clear, descriptive commit messages and include a final CHANGELOG.md.